<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<script>
			//执行环境（execution conext 称为"环境"）是JavaScript中最为重要的一个概念。执行环境定义了函数或变量有权访问的其他数据，决定了他们各自的行为。
			//每个执行环境都有一个与之关联的变量对象(variable object)，环境中定义的所有变量和函数都保存在这个对象中。虽然编写的代码无法访问这个对象，
			//但是解析器在处理数据时会在后台使用它。
			
			//全局执行环境是最外围的一个执行环境。根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。
			//在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为Window对象的属性和方法创建的。
			//某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。
			
			//每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。
			//而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是有这个方便的机制控制着
			
			//当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。 作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。
			//作用域链的前端，始终都是当前执行的代码所在的环境变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。
			//活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。
			//这样一直延续到全局执行环境，全局执行环境的变量对象始终都是作用域链中的最后一个对象。
			
			//标识符解析实验者作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）
			//例子:
			var color="blue";
			function changeColor(){
				color=(color==="blue")?"red":"blue";
			}
			changeColor();
			console.log("Color is now "+ color);
			//这个简单的例子中，函数changeColor()的作用域链包含两个对象，它自己的变量对象（其中定义着arguments对象）和全局环境的变量对象。
			//可以在函数内部访问变量color，就是因为可以在作用域链中找到它。
			
			
			//此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用
			//例
			
			var color1="blue";
			function changeColor1(){
				var anotherColor = "red";
				
				function swapColors(){
					var tempColor =anotherColor;
					anotherColor=color1;
					color1=tempColor;
					//这里可以访问color1、anotherColor、tempColor
				}
				//这里可以访问color1和anotherColor，但是不能访问tempColor
				swapColors();
			}
			//这里只访问color1
			changeColor1();
			console.log(color1);
			
			
			//4.2.1延长作用域链   p75
			//虽然执行环境的类型总共只有两种————全局和局部（函数），但还是有其他办法来演唱作用域链。这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象。
			//该变量对象会在代码执行后被移除。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长:
			//try-catch语句的catch块；with语句
			//这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说,会将指定的对象添加到作用域链中。对于catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误的对象的声明
			//例子
			function buildUrl(){
				var qs="?bebug=true";
				with(location){
					var url=href +qs;
				}
				return url;
			}
			//在此，with语句接收的是location对象，因此其变量对象中就包含了location对象的所有属性和方法，而这个变量对象被添加到了作用域链的前端。
			//buildUrl()函数中定义了一个变量qs。当在with语句中引用变量href时（实际引用的是location.href），可以在当前执行环境的变量对象中找到。
			//当引用变量qs时，引用的则是在buildUrl()中定义的那个变量，而该变量位于函数环境的变量对象中。
			//至于with语句内部，则定义了一个名为url的变量，因而url就成了函数执行环境中的一部分，所以可以作为函数的值被返回。
			
			//4.2.2没有块级作用域
			//JavaScript没有块级作用域经常会导致理解上的困惑。在其他类C语言中，由花括号封闭的代码块都有自己的作用域（如果用ECMAScript的话来讲，就是它们自己的执行环境），因而支持根据条件来定义变量
			//1.申明变量
			//使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。
			//如果初始化变量时没有用var声明，该变量会自动添加到全局环境中。
			//例：
			
			function add(num1,num2){
				var sum=num1+num2;
				return sum;
			}
			var result=add(10,20);
			//console.log(sum);//由于sum不是邮箱的变量，因此会导致错误
			
			//以上代码中的函数add()定义了一个名为sum的局部变量，该变量抱哈加法操作的结果。虽然结果从函数中反悔了，但变量sum在函数外部是访问不到的。
			//如果省略这个例子中的var关键字，那么当add()执行完毕后，sum也将可以访问到：
			
			function add2(num1,num2){
				sum=num1+num2;
				return sum;
			}
			var result2=add2(10,20);
			console.log(sum);
			
			//这个例子的变量sum在被初始化赋值时没有使用var关键字。于是，当调用完add()之后,添加到全局环境的变量sum将继续存在；即使函数已经执行完毕，后面的代码依旧可以访问它。
			
			
			//2.查询标识符 	p77
			//当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。
			//搜索过程是从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。
			//如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。
			//搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中没有找到这个标识符，则意味着该变量尚未声明。
			//通过下面这个示例，可以理解查询标识符的过程：
			
			var color3="blue";
			function getColor(){
				return color3;
			}
			console.log(getColor());
			
			//调用getColor()时会引用变量color3。为了确定变量color3的值，将开始一个两步的搜索过程。
			//首先，搜索getColor()的变量对象，查找其中是否包含一个名为color3的标识符。
			//在没有找到的情况下，搜索继续到下一个变量对象(全局环境的变量对象)，然后在哪里找到了名为color3的标识符。
			//因为搜索到了定义这个变量的变量对象，搜索过程宣告结束。
			
			//在这个搜索过程中，如果存在一个局部的变量的定义，则搜索会自动停止，不再进入另一个变量对象。
			//换句话说，如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符
			
			var color4="blue";
			function getColor1(){
				var color4 = "red";
				return color4;
			}
			console.log(getColor1());
			console.log(color4);
			
			//调用函数时，该变量就会被声明。而当函数的第二行代码执行时，意味着必须找到并返回变量color的值。
			//搜索过程首先从局部环境中开始，而且在这里发现了一个名为color的变量，其值为"red"。
			//因为变量已经找到了，所以搜索即行停止，return语句就使用这个局部变量，并为函数会返回"red"。
			//也就是说，任何位于局部变量color的声明之后的代码，如果不使用window.color都无法访问全局color变量
			
			
			
		</script>
	</body>
</html>
